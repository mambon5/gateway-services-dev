<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>interaction_tunnel &mdash; Gateway communication&#39;s code 01-05-2023 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../_static/style.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> Gateway communication's code
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../modules/backend_script_cloud_comms.html">backend_script_cloud_comms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/backend_script_node_comms.html">backend_script_node_comms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/cloud_settings.html">cloud_settings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/compute_crc.html">compute_crc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/create_message_cloud.html">create_message_cloud</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/create_message_functions.html">create_message_functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/create_message_nodes.html">create_message_nodes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/create_message_specific_functions.html">create_message_specific_functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/database_functions.html">database_functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/global_vars.html">global_vars</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/interaction_tunnel.html">interaction_tunnel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/local_settings.html">local_settings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/message_display_functions.html">message_display_functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/message_display_specific_functions.html">message_display_specific_functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/message_received_class.html">message_received_class</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/message_received_parse_functions.html">message_received_parse_functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/message_specific_parse_functions.html">message_specific_parse_functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/mqtt_credentials.html">mqtt_credentials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/mqtt_interaction_cloud.html">mqtt_interaction_cloud</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/mqtt_interaction_module.html">mqtt_interaction_module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/mqtt_interaction_node_basic.html">mqtt_interaction_node_basic</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/mqtt_interaction_node_main.html">mqtt_interaction_node_main</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/mqtt_interaction_node_temporal.html">mqtt_interaction_node_temporal</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/otap_menu.html">otap_menu</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/otap_specific_functions.html">otap_specific_functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/otap_update_all_nodes.html">otap_update_all_nodes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/prepare_response.html">prepare_response</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/read_gw_database.html">read_gw_database</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/start_gw_comms.html">start_gw_comms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/update_gw_database.html">update_gw_database</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/update_gw_software.html">update_gw_software</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Gateway communication's code</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Module code</a></li>
      <li class="breadcrumb-item active">interaction_tunnel</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for interaction_tunnel</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This file passes messages between:</span>

<span class="sd">1. cloud --&gt; node </span>
<span class="sd">2. node --&gt; cloud</span>

<span class="sd">In order to do so, there are two classes. One that creates a tunnel from cloud --&gt; node and another one that creates the </span>
<span class="sd">tunnel from node --&gt; cloud, respectively.</span>

<span class="sd">1. The *cloud --&gt; node* tunnel, is created when the cloud sends a message to a specific node. In particular, when the gateway receives</span>
<span class="sd">   a cloud message targeted at a node &quot;n&quot;, then it will create a :py:meth:`~mqtt_interaction_node_temporal.mqtt_interaction_node_temporal` class</span>
<span class="sd">   with mode set to &quot;request&quot; in order to send messages to the desired node.</span>
<span class="sd">2. The *node --&gt; cloud* tunnel is created when the gateway detects a new node in its network. It is created in order to receive messages</span>
<span class="sd">   from the cloud to this new node. This tunnel basically creates an </span>
<span class="sd">   :py:meth:`~mqtt_interaction_node_basic.mqtt_interaction_node_basic` class that &quot;listens&quot; to new cloud messages for that node.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">mqtt_interaction_cloud</span>
<span class="kn">import</span> <span class="nn">mqtt_interaction_node_temporal</span>
<span class="kn">import</span> <span class="nn">global_vars</span> <span class="k">as</span> <span class="nn">gvar</span>              <span class="c1">#: import global variables</span>
<span class="kn">from</span> <span class="nn">message_received_class</span> <span class="kn">import</span> <span class="n">RxMsg</span>
<span class="kn">import</span> <span class="nn">otap_specific_functions</span> <span class="k">as</span> <span class="nn">remotap</span>
<span class="kn">from</span> <span class="nn">wirepas_mqtt_library</span> <span class="kn">import</span> <span class="n">WirepasOtapHelper</span>

<div class="viewcode-block" id="cloud_to_node_tunnel"><a class="viewcode-back" href="../modules/interaction_tunnel.html#interaction_tunnel.cloud_to_node_tunnel">[docs]</a><span class="k">class</span> <span class="nc">cloud_to_node_tunnel</span> <span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    This class is created when the gateway receives a cloud message that is pointed at a specific node. The gateway will then</span>
<span class="sd">    create this class in order to transmit the message to the node and make the final step in the transmission. </span>

<span class="sd">    :param cloud_inter: cloud interaction of the gateway. We need to pass the whole interaction in order to allow the tunnel to call it when sending the response to the cloud</span>
<span class="sd">    :type cloud_inter: mqtt_interaction_cloud</span>
<span class="sd">    :param node id: node id to who we wish to communicate</span>
<span class="sd">    :type node id: int</span>
<span class="sd">    :param gw_id: gateway id that creates the tunneling</span>
<span class="sd">    :type gw_id: int</span>
<span class="sd">    :param msg_type: Message type of the message the cloud sent and we want to tunnel to the node</span>
<span class="sd">    :type msg_type: int</span>
<span class="sd">    :param msg_args: additional message arguments</span>
<span class="sd">    :type msg_args: list</span>
<span class="sd">    :param sink_id: Sink id where nodes connect to the gateway</span>
<span class="sd">    :type sink_id: string</span>


<span class="sd">    :does:</span>
<span class="sd">        1. Receives a series of message parameters from a gateway-cloud interaction</span>
<span class="sd">        2. Creates a temporal gateway-node interaction, and passes on the message</span>
<span class="sd">    </span>
<span class="sd">    :structure:</span>
<span class="sd">        1. It has the following methods:</span>
<span class="sd">            - :py:meth:`~interaction_tunnel.cloud_to_node_tunnel.transmit_message_to_node`   </span>

<span class="sd">    :return:</span>

<span class="sd">        Returns a :py:meth:`~mqtt_interaction_node_temporal.mqtt_interaction_node_temporal` class:</span>

<span class="sd">            :to_node_inter: (mqtt_interaction_node_temporal) -- gateway to mesh network interaction of class that the tunnel will create.   </span>
<span class="sd">            </span>
<span class="sd">    &quot;&quot;&quot;</span>


<div class="viewcode-block" id="cloud_to_node_tunnel.__init__"><a class="viewcode-back" href="../modules/interaction_tunnel.html#interaction_tunnel.cloud_to_node_tunnel.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg_type</span><span class="p">,</span> <span class="n">msg_args</span><span class="p">,</span> <span class="n">cloud_inter</span> <span class="p">)</span> <span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize class interaction attributes.    </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="s2">&quot;&lt;init cloud to node tunnel&gt; &quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">msg_type</span> <span class="o">=</span> <span class="n">msg_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_id</span> <span class="o">=</span> <span class="n">cloud_inter</span><span class="o">.</span><span class="n">node_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gw_id</span> <span class="o">=</span> <span class="n">cloud_inter</span><span class="o">.</span><span class="n">gw_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sink_id</span> <span class="o">=</span> <span class="n">cloud_inter</span><span class="o">.</span><span class="n">sink</span>          <span class="c1"># this needs to be changed for production</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">prefix</span> <span class="o">+</span> <span class="s2">&quot;msg type: </span><span class="si">{}</span><span class="s2">, node id: </span><span class="si">{}</span><span class="s2">, gw_id: </span><span class="si">{}</span><span class="s2">, sink_id: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msg_type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gw_id</span><span class="p">,</span>
                                                                                 <span class="bp">self</span><span class="o">.</span><span class="n">sink_id</span> <span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">to_node_inter</span> <span class="o">=</span> <span class="n">mqtt_interaction_node_temporal</span><span class="o">.</span><span class="n">mqtt_interaction_node_temporal</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;request&quot;</span><span class="p">,</span> <span class="n">wni</span><span class="o">=</span> <span class="n">cloud_inter</span><span class="o">.</span><span class="n">wni</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">msg_args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cloud_inter</span> <span class="o">=</span> <span class="n">cloud_inter</span></div>

        <span class="c1"># file for storing messages</span>
    
    
        
<div class="viewcode-block" id="cloud_to_node_tunnel.transmit_message_to_node"><a class="viewcode-back" href="../modules/interaction_tunnel.html#interaction_tunnel.cloud_to_node_tunnel.transmit_message_to_node">[docs]</a>    <span class="k">def</span> <span class="nf">transmit_message_to_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function responsible for sending the message to the mesh network, the final step in the cloud --&gt; node tunnel. </span>
<span class="sd">        </span>
<span class="sd">        :does:</span>
<span class="sd">            1. Sends a node request. Originally, this is determined by the cloud request received by the gateway.</span>
<span class="sd">            2. The :py:meth:`~mqtt_interaction_node_basic.mqtt_interaction_node_basic.request_to_node` function creates a listening thread, for incoming node messages (possible responses to the previous request)</span>
<span class="sd">            3. We create a **thread.join()** which stops any further tunnel execution, until the right response is received or the max waiting time is achieved.</span>
<span class="sd">            4. If a matching response is received, we return True + the node message response. Otherwise we just output a log message notifying the lack of response.</span>
<span class="sd">            5. In order to respond to the cloud, we will call the :py:meth:`~interaction_tunnel.cloud_to_node_tunnel.respond_to_cloud` using the response message from the node, with a modified topic and id.</span>

<span class="sd">         :return:</span>
<span class="sd">            **result** (*list*) --  </span>
<span class="sd">                - [0] - *bool* (True if tunnel to node was successful, False if failed)</span>
<span class="sd">                - [1] - *RxMsg* node response message, or *None* if no message response.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="n">prefix</span> <span class="o">+</span> <span class="s2">&quot;send to node&gt;: &quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">prefix</span> <span class="o">+</span> <span class="s2">&quot;sending cloud-received-message to node&quot;</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">msg_type</span> <span class="ow">in</span> <span class="n">gvar</span><span class="o">.</span><span class="n">MSG_CLOUD_TO_NODE_REQUESTS_LIST</span><span class="p">:</span> <span class="c1"># things that can be asked from cloud to the nodes:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">to_node_inter</span><span class="o">.</span><span class="n">request_to_node</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gw_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sink_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">msg_type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">prefix</span> <span class="o">+</span> <span class="s2">&quot;tunnel message sent to node.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">to_node_inter</span><span class="o">.</span><span class="n">thread</span><span class="o">.</span><span class="n">join</span><span class="p">()</span> <span class="c1"># wait until we receive the right response to the request to the nodes, before continuing execution</span>
            
            <span class="n">msg</span> <span class="o">=</span> <span class="n">RxMsg</span><span class="p">()</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_node_inter</span><span class="o">.</span><span class="n">pub_resp_received</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_node_inter</span><span class="o">.</span><span class="n">node_response</span>
                
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">prefix</span> <span class="o">+</span> <span class="s2">&quot; error: node unresponsive&quot;</span><span class="p">)</span>
                <span class="n">msg</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">gvar</span><span class="o">.</span><span class="n">MSG_TYPE_ERROR</span>
                <span class="n">msg</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">gvar</span><span class="o">.</span><span class="n">ERROR_TYPE_UNRESPONSIVE_NODE</span><span class="p">]</span>
                <span class="c1"># msg.payload = cmsgf.message_to_bytes(msg.id, msg.type, [gvar.ERROR_TYPE_UNRESPONSIVE_NODE], pubtopic=self.cloud_inter.pubtopic, prefix=prefix)</span>
                
            <span class="c1"># the response message has no cloud topic, so we have to assign the topic from the cloud-gw interaction:</span>
            <span class="n">msg</span><span class="o">.</span><span class="n">topic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cloud_inter</span><span class="o">.</span><span class="n">subtopic</span>  <span class="c1"># we set the cloud subscription topic where we received the cloud request, so that the clo0ud response is created proprely</span>

            <span class="c1"># self.respond_to_cloud(msg) # now we can respond to the cloud</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="n">msg</span><span class="p">]</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">msg_type</span> <span class="ow">in</span> <span class="n">gvar</span><span class="o">.</span><span class="n">MSG_SUPPORTED_LIST_CLOUD</span><span class="p">:</span> <span class="c1"># cases that the gateway should answer itself to the cloud about the specific node</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">prefix</span> <span class="o">+</span> <span class="s2">&quot;msg type not in supported list&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span></div></div>
    
   
<div class="viewcode-block" id="tunnel_to_node"><a class="viewcode-back" href="../modules/interaction_tunnel.html#interaction_tunnel.tunnel_to_node">[docs]</a><span class="k">def</span> <span class="nf">tunnel_to_node</span><span class="p">(</span><span class="n">cloud_inter</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">wni</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prepares the message the cloud wants to send to the node. It also sends the message and reports the response.</span>
<span class="sd">       </span>
<span class="sd">        :Note: When the gateway receives a cloud request to get the node version, it won&#39;t send a command directly to the node but it will send an</span>
<span class="sd">        OTAP command to the sink, asking for the scratchpad of that node, which will contain the node version.</span>

<span class="sd">        :does:</span>

<span class="sd">            1. Checks whether the cloud message is targeted towards a node or the gateway itself.</span>
<span class="sd">            2. If it is aimed at a **node**, then it can be either for </span>

<span class="sd">                - getting the node version (in which case a direct otap message to the sink is sent)</span>
<span class="sd">                - Anything else, for which a :class:`cloud_to_node_tunnel &lt;interaction_tunnel.cloud_to_node_tunnel&gt;` class is created, </span>
<span class="sd">                  and the message is sent to the node using the :py:meth:`~interaction_tunnel.cloud_to_node_tunnel.transmit_message_to_node`</span>

<span class="sd">            3. If the message is targeted towards the gateway, then no tunnel to the node is needed, and *None* is sent back to the cloud</span>
<span class="sd">            4. A few seconds after the message is sent to the node, a response message is received.</span>
<span class="sd">            5. The response from the node is returned together with a boolean (True/False) that determines if the tunnel to the node was</span>
<span class="sd">               successful or not.</span>

<span class="sd">        :param cloud_inter: cloud interaction of the gateway. We need to pass the whole interaction in order to allow the tunnel to call it when the node sends the response back to the cloud</span>
<span class="sd">        :type cloud_inter: mqtt_interaction_cloud</span>
<span class="sd">        :param msg: the message received</span>
<span class="sd">        :type msg: RxMsg</span>
<span class="sd">        :param wni: wirepas interface, we need it in order to create the otapHelper and requests node information to the sink directly</span>
<span class="sd">        :type wni: WirepasNetworkInterface  </span>

<span class="sd">        :return:</span>
<span class="sd">            - **result** (*list*)  </span>
<span class="sd">                - [0] - **Success** *(bool)* -- (True if successful, False if failed)</span>
<span class="sd">                - [1] - **Response msg** *(RxMsg)* -- response message from the node. Or error message, or None if no tunnel is needed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">prefix</span>  <span class="o">=</span> <span class="s2">&quot;&lt;tunneling to node&gt; &quot;</span>    
        <span class="n">sub_supertopic</span> <span class="o">=</span> <span class="n">gvar</span><span class="o">.</span><span class="n">get_supertopic</span><span class="p">(</span><span class="n">cloud_inter</span><span class="o">.</span><span class="n">subtopic</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> sub_supertopic: </span><span class="si">{}</span><span class="s2"> with gw id: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">sub_supertopic</span><span class="p">,</span> <span class="n">cloud_inter</span><span class="o">.</span><span class="n">gw_id</span><span class="p">))</span>

        <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">sub_supertopic</span> <span class="o">==</span> <span class="n">gvar</span><span class="o">.</span><span class="n">CLOUD_REQUEST_TO_NODE_MQTT_SUPERTOPIC</span><span class="p">:</span> 
            <span class="k">if</span> <span class="n">msg</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">gvar</span><span class="o">.</span><span class="n">MSG_TYPE_CLOUD_TO_NODE_GET_VERSION</span><span class="p">:</span>
                <span class="c1"># we dont need a direct tunnel to the node, because using otap we can directly ask the sink</span>
                <span class="c1"># the node version, and she will answer properly</span>
                <span class="c1"># ask nodes directly via sink (without expecting a node response) what is the node version</span>
                <span class="c1"># I put this in &quot;read database&quot; section because there was no other place I could put this.</span>
                <span class="n">prefix</span> <span class="o">=</span> <span class="n">prefix</span> <span class="o">+</span> <span class="s2">&quot; node version&gt; &quot;</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">prefix</span> <span class="o">+</span> <span class="s2">&quot;extracting node version...&quot;</span><span class="p">)</span>
                <span class="c1"># the otap needs the otaphelper in order to work :( )</span>
                <span class="n">otapHelper</span> <span class="o">=</span> <span class="n">WirepasOtapHelper</span><span class="p">(</span><span class="n">wni</span><span class="p">,</span>
                                    <span class="nb">int</span><span class="p">(</span><span class="n">gvar</span><span class="o">.</span><span class="n">NETWORK_DEFAULT_CHANNEL</span><span class="p">))</span>

                <span class="n">result</span> <span class="o">=</span> <span class="n">remotap</span><span class="o">.</span><span class="n">get_node_version</span><span class="p">(</span> <span class="n">otapHelper</span><span class="p">,</span> <span class="n">msg</span><span class="o">.</span><span class="n">node_id</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> node version: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># tunnel message to nodes for ALL cloud &gt; node messages, except the node version. For that we don&#39;t </span>
                <span class="c1"># need a cloud &gt; node tunnel:</span>
                <span class="c1"># call for sending node info if response is received</span>
                <span class="n">tunnel</span> <span class="o">=</span> <span class="n">cloud_to_node_tunnel</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">msg</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">cloud_inter</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">tunnel</span><span class="o">.</span><span class="n">transmit_message_to_node</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span>

        
        <span class="c1"># gateway receives a message for itself</span>
        <span class="k">elif</span> <span class="n">sub_supertopic</span> <span class="o">==</span> <span class="n">gvar</span><span class="o">.</span><span class="n">CLOUD_REQUEST_TO_GATEWAY_MQTT_SUPERTOPIC</span><span class="p">:</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="n">prefix</span> <span class="o">+</span> <span class="s2">&quot;cl req to gw&gt; &quot;</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">prefix</span> <span class="o">+</span> <span class="s2">&quot;no tunnel needed right now&quot;</span><span class="p">)</span>
            <span class="c1">#gateway process. i.e. conulst database and issue cloud response </span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">sub_supertopic</span> <span class="ow">in</span> <span class="n">gvar</span><span class="o">.</span><span class="n">SUPERTOPIC_LIST</span><span class="p">:</span>
             <span class="n">prefix</span> <span class="o">=</span> <span class="n">prefix</span> <span class="o">+</span> <span class="s2">&quot;other&gt; &quot;</span>
             <span class="nb">print</span><span class="p">(</span><span class="n">prefix</span> <span class="o">+</span> <span class="s2">&quot;no tunnel expected&quot;</span><span class="p">)</span>
             <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
             <span class="nb">print</span><span class="p">(</span><span class="n">prefix</span> <span class="o">+</span> <span class="s2">&quot;error: no supertopic found!&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="node_to_cloud_tunnel"><a class="viewcode-back" href="../modules/interaction_tunnel.html#interaction_tunnel.node_to_cloud_tunnel">[docs]</a><span class="k">class</span> <span class="nc">node_to_cloud_tunnel</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Class that subscribes the gateway to a global MQTT topic for receiving messages to a specific node.</span>
<span class="sd">    This occurs when an unregistered node sends a message to the gateway.</span>
<span class="sd">    </span>
<span class="sd">    :does:</span>
<span class="sd">        1. Once it&#39;s invoked, it creates a :py:meth:`~mqtt_interaction_cloud.mqtt_interaction_cloud` class that will subscribe to the </span>
<span class="sd">           right MQTT topic in the global broker.</span>
<span class="sd">        2. Every time a cloud message is received in this topic, it will transmit it to the node.</span>
<span class="sd">   </span>
<span class="sd">        </span>
<span class="sd">    :param cloud_inter: cloud interaction with the gateway created by node tigger.</span>
<span class="sd">    :type cloud_inter: mqtt_interaction_cloud</span>
<span class="sd">    :param node_id: node id to who we wish to receive the message from the cloud</span>
<span class="sd">    :type node_id: int</span>
<span class="sd">    :param pubtopic: Publish topic for the cloud interaction. Where should the gateway send its messages to?</span>
<span class="sd">    :type pubtopic: string</span>
<span class="sd">    :param subtopic: Subscription topic for the cloud interaction. Where should the gateway listen to for cloud messages?</span>
<span class="sd">    :type subtopic: string</span>
<span class="sd">    </span>
<span class="sd">    :return:</span>

<span class="sd">        Returns a :py:meth:`~interaction_tunnel.node_to_cloud_tunnel` class with the following attributes:</span>

<span class="sd">            :to_node_inter: (mqtt_interaction_cloud) -- gateway to mesh network interaction of class that the tunnel will create.   </span>
<span class="sd">            </span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="node_to_cloud_tunnel.__init__"><a class="viewcode-back" href="../modules/interaction_tunnel.html#interaction_tunnel.node_to_cloud_tunnel.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">wni</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize class interaction attributes.    </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="s2">&quot;&lt;init node to cloud tunnel&gt; &quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_id</span> <span class="o">=</span> <span class="n">node_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subtopic</span> <span class="o">=</span> <span class="n">gvar</span><span class="o">.</span><span class="n">CLOUD_REQUEST_TO_NODE_MQTT_SUPERTOPIC</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_id</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pubtopic</span> <span class="o">=</span> <span class="n">gvar</span><span class="o">.</span><span class="n">GATEWAY_RESPONSE_TO_CLOUD_REQUEST_TO_NODE_MQTT_SUPERTOPIC</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_id</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">prefix</span> <span class="o">+</span><span class="s2">&quot; node id: </span><span class="si">{}</span><span class="s2">, subtopic: </span><span class="si">{}</span><span class="s2">, pubtopic: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">subtopic</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pubtopic</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cloud_inter</span> <span class="o">=</span> <span class="n">mqtt_interaction_cloud</span><span class="o">.</span><span class="n">mqtt_interaction_cloud</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;listen&quot;</span><span class="p">,</span> <span class="n">subtopic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subtopic</span><span class="p">,</span> 
                                            <span class="n">pubtopic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pubtopic</span><span class="p">,</span> <span class="n">wni</span> <span class="o">=</span> <span class="n">wni</span><span class="p">)</span></div></div>
        <span class="c1"># file for storing messages</span>

<div class="viewcode-block" id="tunnel_to_cloud"><a class="viewcode-back" href="../modules/interaction_tunnel.html#interaction_tunnel.tunnel_to_cloud">[docs]</a><span class="k">def</span> <span class="nf">tunnel_to_cloud</span><span class="p">(</span><span class="n">node_id</span><span class="p">,</span> <span class="n">wni</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Starts a cloud MQTT subscription for a desired node. </span>
<span class="sd">        This interaction is triggered when the gateway receives a messages from an unregistered node.</span>

<span class="sd">        What it does:</span>

<span class="sd">            1. Creates a :class:`node_to_cloud_tunnel &lt;interaction_tunnel.node_to_cloud_tunnel&gt;` class.</span>
<span class="sd">            2. Starts the cloud interaction listening thread to recieved any cloud messages designed to this node</span>

<span class="sd">        :param node_id: id of the node that should receive the cloud messages</span>
<span class="sd">        :type node_id: int</span>
<span class="sd">        :param wni: wirepas interface, we need it in order to create the otapHelper and requests node information to the sink directly</span>
<span class="sd">        :type wni: WirepasNetworkInterface  </span>

<span class="sd">        :return:</span>
<span class="sd">            **result** (*list*)  </span>
<span class="sd">                - [0] - *bool* -- (True if successful, False if failed)</span>
<span class="sd">                - [1] -  :class:`mqtt_interaction_cloud &lt;mqtt_interaction_cloud.mqtt_interaction_cloud&gt;` -- mqtt interaction class with the cloud, the whole class is passed.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">prefix</span>  <span class="o">=</span> <span class="s2">&quot;&lt;tunneling to cloud&gt; &quot;</span>    
        <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{}</span><span class="s2"> Creating cloud tunnel for node </span><span class="si">{}</span><span class="s2"> ...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">node_id</span><span class="p">))</span>
            <span class="n">cloud_tunnel</span> <span class="o">=</span> <span class="n">node_to_cloud_tunnel</span><span class="p">(</span><span class="n">node_id</span><span class="p">,</span> <span class="n">wni</span><span class="p">)</span>      
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> Tunnel set, starting a new thread to listen to cloud&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prefix</span><span class="p">))</span>      
            <span class="n">cloud_tunnel</span><span class="o">.</span><span class="n">cloud_inter</span><span class="o">.</span><span class="n">start_listen_thread</span><span class="p">()</span>

            <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="n">cloud_tunnel</span><span class="o">.</span><span class="n">cloud_inter</span><span class="p">]</span>

        <span class="k">except</span><span class="p">:</span>

            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> tunneling to cloud failed.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prefix</span><span class="p">))</span>
        
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="prepare_cloud_tunnel"><a class="viewcode-back" href="../modules/interaction_tunnel.html#interaction_tunnel.prepare_cloud_tunnel">[docs]</a><span class="k">def</span> <span class="nf">prepare_cloud_tunnel</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">node_inter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if the node that sent the message is registered or not and acts accordingly.</span>

<span class="sd">        :does:</span>
<span class="sd">            1. Checks if the node that sent the message is registered or not. </span>
<span class="sd">            2. If the message comes from an unregistered node, a MQTT cloud subscription will be created via the </span>
<span class="sd">        function :py:meth:`~interaction_tunnel.tunnel_to_cloud`.</span>

<span class="sd">        :param node_inter: main node interaction of the gateway. We need to pass the whole interaction in order to allow the tunnel use the node id for the subscription</span>
<span class="sd">        :type node_inter: mqtt_interaction_node_main</span>
<span class="sd">        :param msg: message received from the nodes</span>
<span class="sd">        :type msg: RxMsg</span>

<span class="sd">        :return:</span>
<span class="sd">            **result** (*list*)  </span>
<span class="sd">                - [0] - *bool* -- (True if successful, False if failed)</span>
<span class="sd">                - [1] - :py:meth:`~mqtt_interaction_cloud.mqtt_interaction_cloud`/*None* -- if a tunneling to the cloud is needed, it passes the whole :py:meth:`~mqtt_interaction_cloud.mqtt_interaction_cloud` class.</span>
<span class="sd">                  Otherwise, it returns *None*.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;&lt;prepare cloud tunnel&gt; &quot;</span>
    <span class="n">node_id_list</span> <span class="o">=</span> <span class="n">node_inter</span><span class="o">.</span><span class="n">node_id_list</span>

    <span class="k">if</span> <span class="n">msg</span><span class="o">.</span><span class="n">node_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">node_id_list</span><span class="p">:</span>
                <span class="n">cloudtunel</span> <span class="o">=</span> <span class="n">tunnel_to_cloud</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">node_id</span><span class="p">,</span> <span class="n">node_inter</span><span class="o">.</span><span class="n">wni</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cloudtunel</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="n">cloudtunel</span></div>



</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Romà Masana.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>